/*
 * Data Extractor Library
 *
 * Extracts all relevant data from an ArchiMate view including:
 * - Visual structure (diagram groups, parent-child visual relationships)
 * - Semantic structure (ArchiMate elements + graphical objects and their relationships)
 *
 * Version 3.0 - Generic type-agnostic extraction
 * - Discovers all element types dynamically (no hardcoding)
 * - Includes graphical objects (groups, notes, connections)
 * - Cycle detection in visual hierarchy
 * - Visual hierarchy enrichment (visualParent, visualChildren)
 */

// =====================================================
// Main Extraction Function
// =====================================================

/**
 * Extract all data from a view for template processing - GENERIC VERSION
 * @param {object} view - The ArchiMate view to extract data from
 * @returns {object} Data object containing visual and semantic structures
 */
function extractViewData(view) {
    console.log("Extracting data from view: " + view.name);

    // Extract visual structure (diagram hierarchy)
    var visualStructure = extractVisualStructure(view);

    // Extract semantic structure (ArchiMate elements and relationships)
    var semanticStructure = extractSemanticStructure(view);

    // Enrich elements with visual hierarchy (parent, children)
    enrichWithVisualHierarchy(semanticStructure.elements, visualStructure);

    // Build convenient collections for templates
    var data = {
        view: extractViewInfo(view),

        // Visual groupings (will be enriched below)
        groups: buildGroupsWithChildren(visualStructure),

        // All elements (ArchiMate + graphical objects)
        elements: semanticStructure.elements,
        elementsByType: semanticStructure.elementsByType,

        // Relationships
        relationships: semanticStructure.relationships
    };

    // Enrich group children with semantic data (relations, specialization, etc.)
    enrichGroupChildren(data.groups, semanticStructure.elementsMap);

    // Log extraction summary with dynamic type discovery
    console.log("Extraction complete:");
    console.log("  - Groups: " + data.groups.length);
    console.log("  - Total elements: " + data.elements.length);

    // Log discovered types dynamically
    var typeNames = [];
    for (var typeName in data.elementsByType) {
        typeNames.push(typeName);
    }
    typeNames.sort();

    for (var i = 0; i < typeNames.length; i++) {
        var typeName = typeNames[i];
        var count = data.elementsByType[typeName].length;
        console.log("    - " + typeName + ": " + count);
    }

    console.log("  - Relationships: " + data.relationships.length);

    return data;
}

// =====================================================
// View Information Extraction
// =====================================================

/**
 * Extract view-level information
 * @param {object} view - The ArchiMate view
 * @returns {object} View information
 */
function extractViewInfo(view) {
    return {
        name: view.name || "",
        documentation: view.documentation || "",
        type: view.type || "",
        imagePath: null  // Will be set by main script
    };
}

// =====================================================
// Visual Structure Extraction
// =====================================================

/**
 * Extract the visual structure of the diagram (groups, containment)
 * @param {object} view - The ArchiMate view
 * @returns {object} Visual structure with parent-child relationships
 */
function extractVisualStructure(view) {
    var structure = {
        objects: {},     // Map of visual objects by ID
        roots: []        // IDs of root-level objects (no parent)
    };

    // Pass 1: Collect all visual objects
    $(view).find().each(function(visualObj) {
        // For ArchiMate elements, get documentation from the underlying concept
        var documentation = "";
        var name = visualObj.name || "";

        // Try to get concept (underlying ArchiMate element) if it exists
        if (visualObj.concept) {
            documentation = visualObj.concept.documentation || "";
            name = visualObj.concept.name || name;
        } else {
            // For groups and notes, use the visual object's own documentation
            documentation = visualObj.documentation || "";
        }

        var objData = {
            id: visualObj.id,
            type: visualObj.type,
            name: name,
            documentation: documentation,
            parentId: null,
            childrenIds: [],
            conceptId: visualObj.concept ? visualObj.concept.id : visualObj.id,
            isGroup: visualObj.type === "diagram-model-group",
            isNote: visualObj.type === "diagram-model-note",
            isRelationship: visualObj.type && visualObj.type.indexOf("relationship") >= 0
        };

        structure.objects[visualObj.id] = objData;
    });

    // Pass 2: Build parent-child relationships
    $(view).find().each(function(visualObj) {
        var obj = structure.objects[visualObj.id];

        if (!obj) {
            return;  // Object not found, skip
        }

        // Find parent group first
        var parentGroup = $(visualObj).parent("diagram-model-group").first();

        // If no parent group, find any visual parent (for nested capabilities)
        var parentElement = null;
        if (!parentGroup) {
            parentElement = $(visualObj).parent().first();
            if (parentElement && parentElement.type === "archimate-diagram-model") {
                parentElement = null; // Root level, no parent
            }
        }

        if (parentGroup) {
            obj.parentId = parentGroup.id;

            // Add this object to parent's children
            if (structure.objects[parentGroup.id]) {
                structure.objects[parentGroup.id].childrenIds.push(visualObj.id);
            }
        } else if (parentElement && parentElement.id) {
            obj.parentId = parentElement.id;

            // Add this object to parent's children
            if (structure.objects[parentElement.id]) {
                structure.objects[parentElement.id].childrenIds.push(visualObj.id);
            }
        } else {
            // No parent, this is a root object
            structure.roots.push(visualObj.id);
        }
    });

    return structure;
}

// =====================================================
// Semantic Structure Extraction
// =====================================================

/**
 * Extract the semantic structure (ArchiMate elements and relationships) - GENERIC VERSION
 * Extracts ALL objects in the view: ArchiMate elements + graphical objects (groups, notes, connections)
 * Elements are deduplicated by ID
 * @param {object} view - The ArchiMate view
 * @returns {object} Semantic structure with elements and relationships
 */
function extractSemanticStructure(view) {
    var structure = {
        elementsMap: {},        // Map of elements by ID (deduplicated)
        elements: [],           // Array of all elements
        elementsByType: {},     // Index by type (dynamic discovery)
        relationships: []       // Array of all relationships
    };

    var seenElementIds = {};  // Track which IDs we've already processed

    // Pass 1: Extract ALL objects (ArchiMate elements + graphical objects)
    $(view).find().each(function(visualObj) {
        // Skip relationships (will be processed separately)
        if (visualObj.type && visualObj.type.indexOf("relationship") >= 0) {
            return;
        }

        var elementId = visualObj.id;

        // Only process each element once (deduplication)
        if (seenElementIds[elementId]) {
            return;
        }
        seenElementIds[elementId] = true;

        // Extract element data
        var name = visualObj.name || "";
        var documentation = "";
        var specialization = null;

        if (visualObj.concept) {
            // ArchiMate element - get data from concept
            name = visualObj.concept.name || name;
            documentation = visualObj.concept.documentation || "";
            specialization = visualObj.concept.specialization || null;
        } else {
            // Graphical object (group, note) - use visual object's data
            documentation = visualObj.documentation || visualObj.content || "";
        }

        var elementData = {
            id: elementId,
            type: visualObj.type,
            name: name,
            documentation: documentation,
            specialization: specialization,
            properties: extractProperties(visualObj),
            incomingRelations: [],
            outgoingRelations: []
        };

        // Add to map and array
        structure.elementsMap[elementId] = elementData;
        structure.elements.push(elementData);

        // Index by type (dynamic discovery)
        if (!structure.elementsByType[elementData.type]) {
            structure.elementsByType[elementData.type] = [];
        }
        structure.elementsByType[elementData.type].push(elementData);
    });

    // Pass 2: Extract relationships
    $(view).find("relationship").each(function(rel) {
        var source = rel.source;
        var target = rel.target;

        if (!source || !target) {
            return;  // Invalid relationship
        }

        var relationshipData = {
            id: rel.id,
            type: rel.type,
            name: rel.name || "",
            documentation: rel.documentation || "",
            sourceId: source.id,
            targetId: target.id,
            source: structure.elementsMap[source.id],
            target: structure.elementsMap[target.id]
        };

        structure.relationships.push(relationshipData);

        // Add to source's outgoing relations
        if (structure.elementsMap[source.id]) {
            structure.elementsMap[source.id].outgoingRelations.push(relationshipData);
        }

        // Add to target's incoming relations
        if (structure.elementsMap[target.id]) {
            structure.elementsMap[target.id].incomingRelations.push(relationshipData);
        }
    });

    return structure;
}

// =====================================================
// Build Collections for Templates
// =====================================================

/**
 * Build groups with their children for template consumption - GENERIC VERSION
 * Includes ALL children (ArchiMate elements + graphical objects)
 * @param {object} visualStructure - Visual structure from extractVisualStructure
 * @returns {array} Array of group objects with their children
 */
function buildGroupsWithChildren(visualStructure) {
    var groups = [];

    /**
     * Helper function to recursively build children hierarchy with cycle detection
     * @param {object} obj - Visual object to process
     * @param {object} visited - Set of visited IDs to detect cycles
     * @param {number} depth - Current recursion depth
     * @returns {object|null} Hierarchy object or null if cycle/max depth
     */
    function buildChildrenHierarchy(obj, visited, depth) {
        // Protection against cycles
        if (visited[obj.id]) {
            console.log("[WARNING] Visual hierarchy cycle detected for: " + obj.name + " (id: " + obj.id + ")");
            return null;
        }

        // Protection against excessive depth
        if (depth > 50) {
            console.log("[WARNING] Max hierarchy depth (50) reached for: " + obj.name);
            return null;
        }

        // Mark as visited
        visited[obj.id] = true;

        var result = {
            id: obj.id,
            type: obj.type,
            name: obj.name,
            documentation: obj.documentation,
            children: []
        };

        // Recursively process ALL children (no filtering by type)
        for (var i = 0; i < obj.childrenIds.length; i++) {
            var childId = obj.childrenIds[i];
            var child = visualStructure.objects[childId];

            if (child) {
                // Recursive call with cycle protection
                var childHierarchy = buildChildrenHierarchy(child, visited, depth + 1);
                if (childHierarchy) {
                    result.children.push(childHierarchy);
                }
            }
        }

        // Unmark (allows same element in different branches)
        delete visited[obj.id];

        return result;
    }

    // Find all diagram-model-group objects
    for (var id in visualStructure.objects) {
        var obj = visualStructure.objects[id];

        if (obj.isGroup) {
            // Build children array with full object data and hierarchy
            var children = [];
            for (var i = 0; i < obj.childrenIds.length; i++) {
                var childId = obj.childrenIds[i];
                var child = visualStructure.objects[childId];

                if (child) {
                    // Start fresh hierarchy with empty visited set
                    var childHierarchy = buildChildrenHierarchy(child, {}, 0);
                    if (childHierarchy) {
                        children.push(childHierarchy);
                    }
                }
            }

            // Build dynamic index by type
            var childrenByType = {};
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (!childrenByType[child.type]) {
                    childrenByType[child.type] = [];
                }
                childrenByType[child.type].push(child);
            }

            // Only include groups that have children
            if (children.length > 0) {
                groups.push({
                    id: obj.id,
                    name: obj.name,
                    documentation: obj.documentation,
                    children: children,
                    childrenByType: childrenByType
                });
            }
        }
    }

    return groups;
}

// =====================================================
// Visual Hierarchy Enrichment
// =====================================================

/**
 * Enrich group children with semantic data from elementsMap
 * Recursively merges visual hierarchy with semantic data (relations, specialization, etc.)
 * @param {array} groups - Array of groups to enrich
 * @param {object} elementsMap - Map of semantic elements by ID
 */
function enrichGroupChildren(groups, elementsMap) {
    /**
     * Recursively enrich a child object with semantic data
     * @param {object} child - Child object from visual hierarchy
     */
    function enrichChild(child) {
        // Find semantic data for this child
        var semanticData = elementsMap[child.id];

        if (semanticData) {
            // Merge semantic data into child object
            child.specialization = semanticData.specialization;
            child.properties = semanticData.properties;

            // Convert properties object to array for template loops
            // This allows templates to use {{#each element.properties}} to iterate
            child.propertiesArray = [];
            if (child.properties) {
                for (var key in child.properties) {
                    if (child.properties.hasOwnProperty(key)) {
                        child.propertiesArray.push({
                            key: key,
                            value: child.properties[key]
                        });
                    }
                }
            }

            child.incomingRelations = semanticData.incomingRelations;
            child.outgoingRelations = semanticData.outgoingRelations;
        }

        // Recursively enrich nested children
        if (child.children && child.children.length > 0) {
            for (var i = 0; i < child.children.length; i++) {
                enrichChild(child.children[i]);
            }
        }
    }

    // Enrich all groups
    for (var i = 0; i < groups.length; i++) {
        var group = groups[i];

        // Enrich each child in the group
        for (var j = 0; j < group.children.length; j++) {
            enrichChild(group.children[j]);
        }
    }
}

/**
 * Enrich elements with visual hierarchy information (parent, children)
 * Links semantic elements to their visual containment structure
 * @param {array} elements - Array of elements to enrich
 * @param {object} visualStructure - Visual structure from extractVisualStructure
 */
function enrichWithVisualHierarchy(elements, visualStructure) {
    // Create index of elements by conceptId for fast lookup
    var elementsByConceptId = {};
    for (var i = 0; i < elements.length; i++) {
        var elem = elements[i];
        elementsByConceptId[elem.id] = elem;
    }

    // Enrich each element with visual hierarchy information
    for (var visualId in visualStructure.objects) {
        var visualObj = visualStructure.objects[visualId];
        var conceptId = visualObj.conceptId;
        var element = elementsByConceptId[conceptId];

        if (element) {
            // Add visual parent reference
            if (visualObj.parentId) {
                var parentVisualObj = visualStructure.objects[visualObj.parentId];
                if (parentVisualObj) {
                    element.visualParent = elementsByConceptId[parentVisualObj.conceptId];
                }
            }

            // Add visual children references
            element.visualChildren = [];
            for (var i = 0; i < visualObj.childrenIds.length; i++) {
                var childVisualObj = visualStructure.objects[visualObj.childrenIds[i]];
                if (childVisualObj) {
                    var childElement = elementsByConceptId[childVisualObj.conceptId];
                    if (childElement) {
                        element.visualChildren.push(childElement);
                    }
                }
            }
        }
    }
}

// =====================================================
// Property Extraction
// =====================================================

/**
 * Extract all properties from an element
 * @param {object} element - ArchiMate element
 * @returns {object} Key-value map of properties
 */
function extractProperties(element) {
    var properties = {};

    if (element && element.prop) {
        // Get all property names
        var propNames = element.prop();

        if (propNames && propNames.length) {
            for (var i = 0; i < propNames.length; i++) {
                var propName = propNames[i];
                var propValue = element.prop(propName);
                if (propValue !== null && propValue !== undefined) {
                    properties[propName] = propValue;
                }
            }
        }
    }

    return properties;
}
