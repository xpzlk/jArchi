/*
 * Template Engine Library
 *
 * Provides template processing functionality with support for:
 * - Simple variables: {{view.name}}
 * - Loops: {{#each items}}...{{/each}}
 * - Conditional loops: {{#each items where field="value"}}
 * - Nested contexts: {{item.name}} inside loops
 *
 * Version 3.0 - Added conditional filtering with AND/OR support
 */

// =====================================================
// File Reading Functions
// =====================================================

/**
 * Read a template file from disk
 * @param {string} filePath - Absolute path to the template file
 * @returns {string} The file content as a string
 */
function readTemplateFile(filePath) {
    var result = '';
    var imports = new JavaImporter(java.net, java.lang, java.io);

    with (imports) {
        var urlObj = null;

        try {
            urlObj = new URL(filePath);
        } catch (e) {
            // If the URL cannot be built, assume it is a file path
            urlObj = new URL(new File(filePath).toURI().toURL());
        }

        var reader = new BufferedReader(new InputStreamReader(urlObj.openStream(), 'UTF-8'));

        var line = reader.readLine();
        while (line != null) {
            result += line + '\n';
            line = reader.readLine();
        }

        reader.close();
    }

    return result;
}

// =====================================================
// Text Processing Functions
// =====================================================

/**
 * Escape markdown special characters in text
 * @param {string} text - Text to escape
 * @returns {string} Escaped text
 */
function escapeMD(text) {
    if (text == null || text === "") {
        return "";
    }
    // Escape pipe characters for markdown tables
    return text.toString().replace(/\|/g, "\\|");
}

/**
 * Convert newlines to HTML breaks for table cells
 * @param {string} text - Text to convert
 * @returns {string} Text with newlines converted to <br>
 */
function newlinesToBr(text) {
    if (text == null || text === "") {
        return "";
    }
    return text.toString().replace(/\r\n/g, "<br>").replace(/\n/g, "<br>");
}

// =====================================================
// Template Processing Functions
// =====================================================

/**
 * Process a template and replace all variables and loops
 * @param {string} template - The template content
 * @param {object} data - Object containing the data to inject into template
 * @returns {string} Processed template
 */
function processTemplate(template, data) {
    console.log("Processing template...");

    var result = template;

    // Process loops first (they can contain simple variables)
    result = processLoops(result, data, null);

    // Then process simple variables
    result = processSimpleVariables(result, data);

    // Clean up empty lines in tables
    // 1. Remove empty lines after table headers (|-|-|)
    result = result.replace(/(\|-\|(-\|)+)\n\n+/g, "$1\n");

    // 2. Remove ALL empty lines between table rows (iterative to handle multiple empty lines)
    // Keep replacing until no more empty lines are found
    var previousResult = "";
    while (previousResult !== result) {
        previousResult = result;
        result = result.replace(/(\|[^\n]+\|)\n\n+(\|[^\n]+\|)/g, "$1\n$2");
    }

    // Check for unknown variables and warn
    warnUnknownVariables(result);

    return result;
}

// =====================================================
// Loop Processing
// =====================================================

/**
 * Process all {{#each}}...{{/each}} loops in the template
 * Uses named closing tags: {{#each groups}}...{{/each groups}}
 * Supports WHERE conditions: {{#each groups where type="capability"}}
 * @param {string} template - Template content
 * @param {object} data - Data object
 * @param {object} parentContext - Context from parent loop (for nested loops)
 * @returns {string} Template with loops expanded
 */
function processLoops(template, data, parentContext) {
    var result = template;

    // Find loop with optional WHERE clause: {{#each XXX where CONDITION}}...{{/each XXX}}
    // The \1 backreference ensures the closing tag matches the opening tag
    var loopPattern = /\{\{#each\s+(\w+)(?:\s+where\s+([^}]+))?\}\}([\s\S]*?)\{\{\/each\s+\1\}\}/;
    var match = result.match(loopPattern);

    if (!match) {
        return result; // No loops found
    }

    var collectionName = match[1]; // e.g., "groups" or "capabilities"
    var whereClause = match[2];    // e.g., 'type="capability" AND properties.Status="Active"' or null
    var loopContent = match[3];    // Content inside the loop (may contain nested loops)
    var fullMatch = match[0];      // The entire {{#each}}...{{/each}} block

    // Determine the singular context name (e.g., "groups" -> "group")
    var contextName = getSingularName(collectionName);

    // Get the collection from data or parent context
    var collection = null;

    // First try to get from parent context (for nested properties like group.capabilities)
    if (parentContext && parentContext[collectionName]) {
        collection = parentContext[collectionName];
    } else if (data[collectionName]) {
        // Otherwise get from global data
        collection = data[collectionName];
    }

    var expanded = "";

    if (collection && collection.length > 0) {
        // Apply WHERE filter if present
        var filteredCollection = collection;
        if (whereClause) {
            filteredCollection = filterCollection(collection, whereClause);
        }

        // Expand the loop for each item
        for (var i = 0; i < filteredCollection.length; i++) {
            var item = filteredCollection[i];
            var itemContent = loopContent;

            // Replace variables in this iteration
            itemContent = replaceContextVariables(itemContent, contextName, item, data);

            // Process any nested loops with this item as parent context (RECURSIVE)
            itemContent = processLoops(itemContent, data, item);

            expanded += itemContent;
        }
    }

    // Replace this loop with the expanded content
    result = result.replace(fullMatch, expanded);

    // Continue processing any remaining loops at this level (ITERATIVE)
    result = processLoops(result, data, parentContext);

    return result;
}

// =====================================================
// Conditional Filtering
// =====================================================

/**
 * Filter a collection based on WHERE clause
 * Supports: field="value", field!="value", field contains "text", field exists, field not exists
 * Logical operators: AND, OR (AND has priority)
 * @param {array} collection - Array of items to filter
 * @param {string} whereClause - WHERE condition (e.g., 'type="capability" AND properties.Status="Active"')
 * @returns {array} Filtered collection
 */
function filterCollection(collection, whereClause) {
    var filtered = [];

    // Parse WHERE clause into OR groups (OR has lowest priority)
    var orGroups = parseOrGroups(whereClause);

    for (var i = 0; i < collection.length; i++) {
        var item = collection[i];

        // Item passes if ANY OR group is satisfied
        var passesFilter = false;

        for (var j = 0; j < orGroups.length; j++) {
            var andConditions = orGroups[j];

            // All AND conditions in this group must be true
            var allAndTrue = true;

            for (var k = 0; k < andConditions.length; k++) {
                if (!evaluateCondition(item, andConditions[k])) {
                    allAndTrue = false;
                    break;
                }
            }

            if (allAndTrue) {
                passesFilter = true;
                break; // No need to check other OR groups
            }
        }

        if (passesFilter) {
            filtered.push(item);
        }
    }

    return filtered;
}

/**
 * Parse WHERE clause into OR groups, each containing AND conditions
 * Example: "A AND B OR C AND D" -> [[A, B], [C, D]]
 * @param {string} whereClause - WHERE condition string
 * @returns {array} Array of OR groups, each group is an array of AND conditions
 */
function parseOrGroups(whereClause) {
    var orGroups = [];

    // Split by OR (case insensitive)
    var orParts = whereClause.split(/\s+OR\s+/i);

    for (var i = 0; i < orParts.length; i++) {
        var orPart = orParts[i].trim();

        // Split by AND (case insensitive)
        var andParts = orPart.split(/\s+AND\s+/i);

        var andConditions = [];
        for (var j = 0; j < andParts.length; j++) {
            var condition = andParts[j].trim();
            if (condition) {
                andConditions.push(condition);
            }
        }

        if (andConditions.length > 0) {
            orGroups.push(andConditions);
        }
    }

    return orGroups;
}

/**
 * Evaluate a single condition against an item
 * @param {object} item - Item to test
 * @param {string} condition - Condition string (e.g., 'type="capability"' or 'properties.Status exists')
 * @returns {boolean} True if condition is met
 */
function evaluateCondition(item, condition) {
    // Pattern: field operator value
    // Operators: =, !=, contains, exists, not exists

    // Check for "not exists"
    var notExistsMatch = condition.match(/^([\w.]+)\s+not\s+exists$/i);
    if (notExistsMatch) {
        var field = notExistsMatch[1];
        var value = getNestedProperty(item, field);
        return value === null || value === undefined || value === "";
    }

    // Check for "exists"
    var existsMatch = condition.match(/^([\w.]+)\s+exists$/i);
    if (existsMatch) {
        var field = existsMatch[1];
        var value = getNestedProperty(item, field);
        return value !== null && value !== undefined && value !== "";
    }

    // Check for "contains"
    var containsMatch = condition.match(/^([\w.]+)\s+contains\s+"([^"]+)"$/i);
    if (containsMatch) {
        var field = containsMatch[1];
        var searchText = containsMatch[2];
        var value = getNestedProperty(item, field);

        if (value === null || value === undefined) {
            return false;
        }

        return value.toString().indexOf(searchText) >= 0;
    }

    // Check for != (not equal)
    var notEqualMatch = condition.match(/^([\w.]+)\s*!=\s*"([^"]+)"$/);
    if (notEqualMatch) {
        var field = notEqualMatch[1];
        var expectedValue = notEqualMatch[2];
        var actualValue = getNestedProperty(item, field);

        if (actualValue === null || actualValue === undefined) {
            return true; // null/undefined is not equal to any value
        }

        return actualValue.toString() !== expectedValue;
    }

    // Check for = (equal)
    var equalMatch = condition.match(/^([\w.]+)\s*=\s*"([^"]+)"$/);
    if (equalMatch) {
        var field = equalMatch[1];
        var expectedValue = equalMatch[2];
        var actualValue = getNestedProperty(item, field);

        if (actualValue === null || actualValue === undefined) {
            return false;
        }

        return actualValue.toString() === expectedValue;
    }

    // Unknown condition format - log warning and return false
    console.log("[WARNING] Unknown condition format: " + condition);
    return false;
}

/**
 * Get singular form of a collection name
 * @param {string} plural - Plural name (e.g., "groups")
 * @returns {string} Singular name (e.g., "group")
 */
function getSingularName(plural) {
    // Simple pluralization rules
    if (plural.endsWith("ies")) {
        return plural.substring(0, plural.length - 3) + "y";
    } else if (plural.endsWith("s")) {
        return plural.substring(0, plural.length - 1);
    }
    return plural;
}

/**
 * Replace variables in a loop iteration context
 * @param {string} content - Content to process
 * @param {string} contextName - Name of the context (e.g., "group")
 * @param {object} contextData - Data for this context
 * @param {object} globalData - Global data object
 * @returns {string} Content with variables replaced
 */
function replaceContextVariables(content, contextName, contextData, globalData) {
    var result = content;

    // Pattern: {{contextName.propertyName}}
    var contextPattern = new RegExp("\\{\\{" + contextName + "\\.([^}]+)\\}\\}", "g");

    result = result.replace(contextPattern, function(match, propertyPath) {
        var value = getNestedProperty(contextData, propertyPath);

        if (value === null || value === undefined) {
            return "";
        }

        // For documentation in tables, convert newlines to <br>
        if (propertyPath === "documentation") {
            return escapeMD(newlinesToBr(value));
        }

        return escapeMD(value);
    });

    return result;
}

/**
 * Get a nested property from an object using dot notation
 * @param {object} obj - Object to get property from
 * @param {string} path - Property path (e.g., "name" or "properties.MyProp")
 * @returns {*} Property value or null if not found
 */
function getNestedProperty(obj, path) {
    var parts = path.split(".");
    var current = obj;

    for (var i = 0; i < parts.length; i++) {
        if (current === null || current === undefined) {
            return null;
        }

        var part = parts[i];

        // Special handling for "properties" object
        if (part === "properties" && current.properties) {
            current = current.properties;
        } else if (current[part] !== undefined) {
            current = current[part];
        } else {
            return null;
        }
    }

    return current;
}

// =====================================================
// Simple Variable Processing
// =====================================================

/**
 * Process simple variables like {{view.name}}
 * @param {string} template - Template content
 * @param {object} data - Data object
 * @returns {string} Template with simple variables replaced
 */
function processSimpleVariables(template, data) {
    var result = template;

    // Replace {{view.name}}
    if (data.view) {
        result = result.replace(/\{\{view\.name\}\}/g, escapeMD(data.view.name));
        result = result.replace(/\{\{view\.documentation\}\}/g, escapeMD(data.view.documentation));
    }

    // Replace {{view.image.png}} with image markdown
    if (data.imageFilename) {
        result = result.replace(/\{\{view\.image\.png\}\}/g, "![" + data.view.name + "](" + data.imageFilename + ")");
        result = result.replace(/\{\{view\.image\.svg\}\}/g, "![" + data.view.name + "](" + data.imageFilename + ")");
    }

    return result;
}

// =====================================================
// Validation and Warnings
// =====================================================

/**
 * Check for remaining {{variables}} in the result and warn about them
 * @param {string} result - Processed template
 */
function warnUnknownVariables(result) {
    var unknownPattern = /\{\{([^}]+)\}\}/g;
    var match;
    var unknownVars = [];

    while ((match = unknownPattern.exec(result)) !== null) {
        var varName = match[1];

        // Skip #each and /each markers
        if (varName.startsWith("#") || varName.startsWith("/")) {
            continue;
        }

        // Avoid duplicates
        var alreadyWarned = false;
        for (var i = 0; i < unknownVars.length; i++) {
            if (unknownVars[i] === varName) {
                alreadyWarned = true;
                break;
            }
        }
        if (!alreadyWarned) {
            unknownVars.push(varName);
        }
    }

    // Display warnings for unknown variables
    if (unknownVars.length > 0) {
        console.log("");
        console.log("[WARNING] Variables inconnues dans le template:");
        for (var i = 0; i < unknownVars.length; i++) {
            console.log("  - {{" + unknownVars[i] + "}}");
        }
        console.log("Ces variables n'ont pas été remplacées.");
    }
}
