/*
 * Template Engine Library
 *
 * Provides template processing functionality with support for:
 * - Simple variables: {{view.name}}
 * - Loops: {{#each items}}...{{/each}}
 * - Conditional loops: {{#each items where field="value"}}
 * - Nested contexts: {{item.name}} inside loops
 *
 * Version 3.0 - Added conditional filtering with AND/OR support
 */

// =====================================================
// File Reading Functions
// =====================================================

/**
 * Read a template file from disk
 * @param {string} filePath - Absolute path to the template file
 * @returns {string} The file content as a string
 */
function readTemplateFile(filePath) {
    var result = '';
    var imports = new JavaImporter(java.net, java.lang, java.io);

    with (imports) {
        var urlObj = null;

        try {
            urlObj = new URL(filePath);
        } catch (e) {
            // If the URL cannot be built, assume it is a file path
            urlObj = new URL(new File(filePath).toURI().toURL());
        }

        var reader = new BufferedReader(new InputStreamReader(urlObj.openStream(), 'UTF-8'));

        var line = reader.readLine();
        while (line != null) {
            result += line + '\n';
            line = reader.readLine();
        }

        reader.close();
    }

    return result;
}

// =====================================================
// Text Processing Functions
// =====================================================

/**
 * Escape markdown special characters in text
 * @param {string} text - Text to escape
 * @returns {string} Escaped text
 */
function escapeMD(text) {
    if (text == null || text === "") {
        return "";
    }
    // Escape pipe characters for markdown tables
    return text.toString().replace(/\|/g, "\\|");
}

/**
 * Convert newlines to HTML breaks for table cells
 * @param {string} text - Text to convert
 * @returns {string} Text with newlines converted to <br>
 */
function newlinesToBr(text) {
    if (text == null || text === "") {
        return "";
    }
    return text.toString().replace(/\r\n/g, "<br>").replace(/\n/g, "<br>");
}

// =====================================================
// Template Processing Functions
// =====================================================

/**
 * Process a template and replace all variables and loops
 * @param {string} template - The template content
 * @param {object} data - Object containing the data to inject into template
 * @returns {string} Processed template
 */
function processTemplate(template, data) {
    console.log("Processing template...");

    var result = template;

    // Process loops first (conditionals inside loops will be processed during loop expansion)
    result = processLoops(result, data, null);

    // Process any remaining top-level conditionals (not inside loops)
    result = processConditionals(result, data, null);

    // Then process simple variables
    result = processSimpleVariables(result, data);

    // Clean up empty lines in tables
    // 1. Remove empty lines after table headers (|-|-|)
    result = result.replace(/(\|-\|(-\|)+)\n\n+/g, "$1\n");

    // 2. Remove ALL empty lines between table rows (iterative to handle multiple empty lines)
    // Keep replacing until no more empty lines are found
    var previousResult = "";
    while (previousResult !== result) {
        previousResult = result;
        result = result.replace(/(\|[^\n]+\|)\n\n+(\|[^\n]+\|)/g, "$1\n$2");
    }

    // Check for unknown variables and warn
    warnUnknownVariables(result);

    return result;
}

// =====================================================
// Conditional Processing
// =====================================================

/**
 * Process all {{#if}}...{{/if}} conditionals in the template
 * Supports: {{#if property.length > 0}}, {{#if property exists}}, {{#if property}}
 * @param {string} template - Template content
 * @param {object} data - Data object
 * @param {object} parentContext - Context from parent loop (for nested conditionals)
 * @returns {string} Template with conditionals processed
 */
function processConditionals(template, data, parentContext) {
    var result = template;

    // Pattern: {{#if CONDITION}}...{{/if}}
    var conditionalPattern = /\{\{#if\s+([^}]+)\}\}([\s\S]*?)\{\{\/if\}\}/;
    var match = result.match(conditionalPattern);

    if (!match) {
        return result; // No conditionals found
    }

    var condition = match[1].trim();  // e.g., "orphanCapabilities.length > 0"
    var conditionalContent = match[2]; // Content inside the conditional
    var fullMatch = match[0];          // The entire {{#if}}...{{/if}} block

    // Evaluate the condition
    var conditionResult = evaluateIfCondition(condition, data, parentContext);

    var replacement = "";
    if (conditionResult) {
        // Condition is true, include the content (don't process it yet, let the caller handle nested processing)
        replacement = conditionalContent;
    }
    // else: Condition is false, replace with empty string

    // Replace this conditional with the result
    result = result.replace(fullMatch, replacement);

    // Continue processing any remaining conditionals at this level (ITERATIVE)
    result = processConditionals(result, data, parentContext);

    return result;
}

/**
 * Evaluate an if condition
 * Supports: property.length > 0, property.length == 0, property exists, property
 * @param {string} condition - Condition string
 * @param {object} data - Global data object
 * @param {object} parentContext - Parent context (for nested conditions)
 * @returns {boolean} True if condition is met
 */
function evaluateIfCondition(condition, data, parentContext) {
    // Pattern: property.length > number
    var lengthGreaterMatch = condition.match(/^([\w.]+)\.length\s*>\s*(\d+)$/);
    if (lengthGreaterMatch) {
        var propertyPath = lengthGreaterMatch[1];
        var threshold = parseInt(lengthGreaterMatch[2], 10);
        var value = getPropertyFromContext(propertyPath, data, parentContext);

        if (value && value.length !== undefined) {
            return value.length > threshold;
        }
        return false;
    }

    // Pattern: property.length == number
    var lengthEqualMatch = condition.match(/^([\w.]+)\.length\s*==\s*(\d+)$/);
    if (lengthEqualMatch) {
        var propertyPath = lengthEqualMatch[1];
        var expectedLength = parseInt(lengthEqualMatch[2], 10);
        var value = getPropertyFromContext(propertyPath, data, parentContext);

        if (value && value.length !== undefined) {
            return value.length == expectedLength;
        }
        return false;
    }

    // Pattern: property.length < number
    var lengthLessMatch = condition.match(/^([\w.]+)\.length\s*<\s*(\d+)$/);
    if (lengthLessMatch) {
        var propertyPath = lengthLessMatch[1];
        var threshold = parseInt(lengthLessMatch[2], 10);
        var value = getPropertyFromContext(propertyPath, data, parentContext);

        if (value && value.length !== undefined) {
            return value.length < threshold;
        }
        return false;
    }

    // Pattern: property exists
    var existsMatch = condition.match(/^([\w.]+)\s+exists$/);
    if (existsMatch) {
        var propertyPath = existsMatch[1];
        var value = getPropertyFromContext(propertyPath, data, parentContext);
        return value !== null && value !== undefined && value !== "";
    }

    // Pattern: property (truthy check)
    var truthyMatch = condition.match(/^([\w.]+)$/);
    if (truthyMatch) {
        var propertyPath = truthyMatch[1];
        var value = getPropertyFromContext(propertyPath, data, parentContext);

        // Truthy check
        if (value === null || value === undefined || value === "" || value === false) {
            return false;
        }

        // Empty array is falsy
        if (value.length !== undefined && value.length === 0) {
            return false;
        }

        return true;
    }

    // Unknown condition format
    console.log("[WARNING] Unknown {{#if}} condition format: " + condition);
    return false;
}

/**
 * Get a property value from data or parent context
 * @param {string} propertyPath - Property path (e.g., "orphanCapabilities" or "group.name")
 * @param {object} data - Global data object
 * @param {object} parentContext - Parent context
 * @returns {*} Property value or null
 */
function getPropertyFromContext(propertyPath, data, parentContext) {
    // First try to get from parent context (for nested properties)
    if (parentContext) {
        var value = getNestedProperty(parentContext, propertyPath);
        if (value !== null) {
            return value;
        }
    }

    // Otherwise get from global data
    return getNestedProperty(data, propertyPath);
}

// =====================================================
// Loop Processing
// =====================================================

/**
 * Process all {{#each}}...{{/each}} loops in the template
 * Uses named closing tags: {{#each groups}}...{{/each groups}}
 * Supports WHERE conditions: {{#each groups where type="capability"}}
 * Supports nested paths: {{#each group.children}}
 * @param {string} template - Template content
 * @param {object} data - Data object
 * @param {object} parentContext - Context from parent loop (for nested loops)
 * @returns {string} Template with loops expanded
 */
function processLoops(template, data, parentContext) {
    var result = template;

    // Find loop with optional WHERE clause: {{#each XXX where CONDITION}}...{{/each XXX}}
    // The \1 backreference ensures the closing tag matches the opening tag
    // Support paths with dots: group.children, element.visualChildren
    var loopPattern = /\{\{#each\s+([\w.]+)(?:\s+where\s+([^}]+))?\}\}([\s\S]*?)\{\{\/each\s+\1\}\}/;
    var match = result.match(loopPattern);

    if (!match) {
        return result; // No loops found
    }

    var collectionName = match[1]; // e.g., "groups", "capabilities", or "group.children"
    var whereClause = match[2];    // e.g., 'type="capability" AND properties.Status="Active"' or null
    var loopContent = match[3];    // Content inside the loop (may contain nested loops)
    var fullMatch = match[0];      // The entire {{#each}}...{{/each}} block

    // Extract last segment for singular name (e.g., "group.children" -> "children" -> "child")
    var lastSegment = collectionName.indexOf(".") >= 0
        ? collectionName.split(".").pop()
        : collectionName;
    var contextName = getSingularName(lastSegment);

    // Detect naming conflict: if parentContext already has a property with this contextName,
    // it means we're in a nested loop with the same collection name (e.g., child.children inside group.children)
    // In this case, prefix with the parent's type to create a unique context name
    if (parentContext && parentContext.type) {
        // Check if this would create a conflict by seeing if parentContext matches the contextName
        // For example: if contextName is "child" and we're iterating over child.children
        var parentType = parentContext.type;

        // If the singular form matches, we have a conflict - prefix with parent's element type
        // This creates names like "capability-child" instead of just "child"
        if (collectionName.indexOf(".") >= 0) {
            var parentPrefix = collectionName.split(".")[0]; // "child" from "child.children"
            if (parentPrefix === contextName) {
                // Conflict detected: use "nested" + contextName
                contextName = "nested" + contextName.charAt(0).toUpperCase() + contextName.slice(1);
            }
        }
    }

    // Get the collection from data or parent context
    var collection = null;

    // Support nested paths (group.children, element.visualChildren, etc.)
    if (collectionName.indexOf(".") >= 0) {
        // Extract the property name (last segment after the dot)
        var segments = collectionName.split(".");
        var propertyName = segments[segments.length - 1]; // "children", "visualChildren", etc.

        // Look for the property in parent context first
        if (parentContext && parentContext[propertyName]) {
            collection = parentContext[propertyName];
        } else {
            // Fallback: try full path in global data
            collection = getPropertyFromContext(collectionName, data, null);
        }
    } else {
        // Simple property name: use original logic
        // First try to get from parent context
        if (parentContext && parentContext[collectionName]) {
            collection = parentContext[collectionName];
        } else if (data[collectionName]) {
            // Otherwise get from global data
            collection = data[collectionName];
        }
    }

    var expanded = "";

    if (collection && collection.length > 0) {
        // Apply WHERE filter if present
        var filteredCollection = collection;
        if (whereClause) {
            filteredCollection = filterCollection(collection, whereClause);
        }

        // Expand the loop for each item
        for (var i = 0; i < filteredCollection.length; i++) {
            var item = filteredCollection[i];
            var itemContent = loopContent;

            // Process any conditionals within this iteration (with item as parent context)
            itemContent = processConditionals(itemContent, data, item);

            // Replace variables in this iteration
            itemContent = replaceContextVariables(itemContent, contextName, item, data);

            // Process any nested loops with this item as parent context (RECURSIVE)
            itemContent = processLoops(itemContent, data, item);

            expanded += itemContent;
        }
    }

    // Replace this loop with the expanded content
    result = result.replace(fullMatch, expanded);

    // Continue processing any remaining loops at this level (ITERATIVE)
    result = processLoops(result, data, parentContext);

    return result;
}

// =====================================================
// Conditional Filtering
// =====================================================

/**
 * Filter a collection based on WHERE clause
 * Supports: field="value", field!="value", field contains "text", field exists, field not exists
 * Logical operators: AND, OR (AND has priority)
 * @param {array} collection - Array of items to filter
 * @param {string} whereClause - WHERE condition (e.g., 'type="capability" AND properties.Status="Active"')
 * @returns {array} Filtered collection
 */
function filterCollection(collection, whereClause) {
    var filtered = [];

    // Parse WHERE clause into OR groups (OR has lowest priority)
    var orGroups = parseOrGroups(whereClause);

    for (var i = 0; i < collection.length; i++) {
        var item = collection[i];

        // Item passes if ANY OR group is satisfied
        var passesFilter = false;

        for (var j = 0; j < orGroups.length; j++) {
            var andConditions = orGroups[j];

            // All AND conditions in this group must be true
            var allAndTrue = true;

            for (var k = 0; k < andConditions.length; k++) {
                if (!evaluateCondition(item, andConditions[k])) {
                    allAndTrue = false;
                    break;
                }
            }

            if (allAndTrue) {
                passesFilter = true;
                break; // No need to check other OR groups
            }
        }

        if (passesFilter) {
            filtered.push(item);
        }
    }

    return filtered;
}

/**
 * Parse WHERE clause into OR groups, each containing AND conditions
 * Example: "A AND B OR C AND D" -> [[A, B], [C, D]]
 * @param {string} whereClause - WHERE condition string
 * @returns {array} Array of OR groups, each group is an array of AND conditions
 */
function parseOrGroups(whereClause) {
    var orGroups = [];

    // Split by OR (case insensitive)
    var orParts = whereClause.split(/\s+OR\s+/i);

    for (var i = 0; i < orParts.length; i++) {
        var orPart = orParts[i].trim();

        // Split by AND (case insensitive)
        var andParts = orPart.split(/\s+AND\s+/i);

        var andConditions = [];
        for (var j = 0; j < andParts.length; j++) {
            var condition = andParts[j].trim();
            if (condition) {
                andConditions.push(condition);
            }
        }

        if (andConditions.length > 0) {
            orGroups.push(andConditions);
        }
    }

    return orGroups;
}

/**
 * Evaluate a single condition against an item
 * @param {object} item - Item to test
 * @param {string} condition - Condition string (e.g., 'type="capability"' or 'properties.Status exists')
 * @returns {boolean} True if condition is met
 */
function evaluateCondition(item, condition) {
    // Pattern: field operator value
    // Operators: =, !=, contains, exists, not exists

    // Check for "not exists"
    var notExistsMatch = condition.match(/^([\w.]+)\s+not\s+exists$/i);
    if (notExistsMatch) {
        var field = notExistsMatch[1];
        var value = getNestedProperty(item, field);
        return value === null || value === undefined || value === "";
    }

    // Check for "exists"
    var existsMatch = condition.match(/^([\w.]+)\s+exists$/i);
    if (existsMatch) {
        var field = existsMatch[1];
        var value = getNestedProperty(item, field);
        return value !== null && value !== undefined && value !== "";
    }

    // Check for "contains"
    var containsMatch = condition.match(/^([\w.]+)\s+contains\s+"([^"]+)"$/i);
    if (containsMatch) {
        var field = containsMatch[1];
        var searchText = containsMatch[2];
        var value = getNestedProperty(item, field);

        if (value === null || value === undefined) {
            return false;
        }

        return value.toString().indexOf(searchText) >= 0;
    }

    // Check for != (not equal)
    var notEqualMatch = condition.match(/^([\w.]+)\s*!=\s*"([^"]*)"$/);
    if (notEqualMatch) {
        var field = notEqualMatch[1];
        var expectedValue = notEqualMatch[2];
        var actualValue = getNestedProperty(item, field);

        if (actualValue === null || actualValue === undefined) {
            return true; // null/undefined is not equal to any value
        }

        return actualValue.toString() !== expectedValue;
    }

    // Check for = (equal)
    var equalMatch = condition.match(/^([\w.]+)\s*=\s*"([^"]*)"$/);
    if (equalMatch) {
        var field = equalMatch[1];
        var expectedValue = equalMatch[2];
        var actualValue = getNestedProperty(item, field);

        if (actualValue === null || actualValue === undefined) {
            return false;
        }

        return actualValue.toString() === expectedValue;
    }

    // Check for property.length > number
    var lengthGreaterMatch = condition.match(/^([\w.]+)\.length\s*>\s*(\d+)$/);
    if (lengthGreaterMatch) {
        var field = lengthGreaterMatch[1];
        var threshold = parseInt(lengthGreaterMatch[2], 10);
        var value = getNestedProperty(item, field);

        if (value && value.length !== undefined) {
            return value.length > threshold;
        }
        return false;
    }

    // Check for property.length >= number
    var lengthGreaterEqualMatch = condition.match(/^([\w.]+)\.length\s*>=\s*(\d+)$/);
    if (lengthGreaterEqualMatch) {
        var field = lengthGreaterEqualMatch[1];
        var threshold = parseInt(lengthGreaterEqualMatch[2], 10);
        var value = getNestedProperty(item, field);

        if (value && value.length !== undefined) {
            return value.length >= threshold;
        }
        return false;
    }

    // Check for property.length < number
    var lengthLessMatch = condition.match(/^([\w.]+)\.length\s*<\s*(\d+)$/);
    if (lengthLessMatch) {
        var field = lengthLessMatch[1];
        var threshold = parseInt(lengthLessMatch[2], 10);
        var value = getNestedProperty(item, field);

        if (value && value.length !== undefined) {
            return value.length < threshold;
        }
        return false;
    }

    // Check for property.length <= number
    var lengthLessEqualMatch = condition.match(/^([\w.]+)\.length\s*<=\s*(\d+)$/);
    if (lengthLessEqualMatch) {
        var field = lengthLessEqualMatch[1];
        var threshold = parseInt(lengthLessEqualMatch[2], 10);
        var value = getNestedProperty(item, field);

        if (value && value.length !== undefined) {
            return value.length <= threshold;
        }
        return false;
    }

    // Check for property.length == number
    var lengthEqualMatch = condition.match(/^([\w.]+)\.length\s*==\s*(\d+)$/);
    if (lengthEqualMatch) {
        var field = lengthEqualMatch[1];
        var expectedLength = parseInt(lengthEqualMatch[2], 10);
        var value = getNestedProperty(item, field);

        if (value && value.length !== undefined) {
            return value.length == expectedLength;
        }
        return false;
    }

    // Unknown condition format - log warning and return false
    console.log("[WARNING] Unknown condition format: " + condition);
    return false;
}

/**
 * Get singular form of a collection name
 * @param {string} plural - Plural name (e.g., "groups")
 * @returns {string} Singular name (e.g., "group")
 */
function getSingularName(plural) {
    // Special cases
    if (plural === "children") {
        return "child";
    }

    // Simple pluralization rules
    if (plural.endsWith("ies")) {
        return plural.substring(0, plural.length - 3) + "y";
    } else if (plural.endsWith("s")) {
        return plural.substring(0, plural.length - 1);
    }
    return plural;
}

/**
 * Replace variables in a loop iteration context
 * @param {string} content - Content to process
 * @param {string} contextName - Name of the context (e.g., "group")
 * @param {object} contextData - Data for this context
 * @param {object} globalData - Global data object
 * @returns {string} Content with variables replaced
 */
function replaceContextVariables(content, contextName, contextData, globalData) {
    var result = content;

    // Pattern: {{contextName.propertyName}}
    var contextPattern = new RegExp("\\{\\{" + contextName + "\\.([^}]+)\\}\\}", "g");

    result = result.replace(contextPattern, function(match, propertyPath) {
        var value = getNestedProperty(contextData, propertyPath);

        if (value === null || value === undefined) {
            return "";
        }

        // For documentation in tables, convert newlines to <br>
        if (propertyPath === "documentation") {
            return escapeMD(newlinesToBr(value));
        }

        return escapeMD(value);
    });

    return result;
}

/**
 * Get a nested property from an object using dot notation
 * @param {object} obj - Object to get property from
 * @param {string} path - Property path (e.g., "name" or "properties.MyProp")
 * @returns {*} Property value or null if not found
 */
function getNestedProperty(obj, path) {
    var parts = path.split(".");
    var current = obj;

    for (var i = 0; i < parts.length; i++) {
        if (current === null || current === undefined) {
            return null;
        }

        var part = parts[i];

        // Special handling for "properties" object
        if (part === "properties" && current.properties) {
            current = current.properties;
        } else if (current[part] !== undefined) {
            current = current[part];
        } else {
            return null;
        }
    }

    return current;
}

// =====================================================
// Simple Variable Processing
// =====================================================

/**
 * Process simple variables like {{view.name}}
 * @param {string} template - Template content
 * @param {object} data - Data object
 * @returns {string} Template with simple variables replaced
 */
function processSimpleVariables(template, data) {
    var result = template;

    // Replace {{view.name}}
    if (data.view) {
        result = result.replace(/\{\{view\.name\}\}/g, escapeMD(data.view.name));
        result = result.replace(/\{\{view\.documentation\}\}/g, escapeMD(data.view.documentation));
    }

    // Replace {{view.image.png}} with image markdown
    if (data.imageFilename) {
        result = result.replace(/\{\{view\.image\.png\}\}/g, "![" + data.view.name + "](" + data.imageFilename + ")");
        result = result.replace(/\{\{view\.image\.svg\}\}/g, "![" + data.view.name + "](" + data.imageFilename + ")");
    }

    return result;
}

// =====================================================
// Validation and Warnings
// =====================================================

/**
 * Check for remaining {{variables}} in the result and warn about them
 * @param {string} result - Processed template
 */
function warnUnknownVariables(result) {
    var unknownPattern = /\{\{([^}]+)\}\}/g;
    var match;
    var unknownVars = [];

    while ((match = unknownPattern.exec(result)) !== null) {
        var varName = match[1];

        // Skip #each and /each markers
        if (varName.startsWith("#") || varName.startsWith("/")) {
            continue;
        }

        // Avoid duplicates
        var alreadyWarned = false;
        for (var i = 0; i < unknownVars.length; i++) {
            if (unknownVars[i] === varName) {
                alreadyWarned = true;
                break;
            }
        }
        if (!alreadyWarned) {
            unknownVars.push(varName);
        }
    }

    // Display warnings for unknown variables
    if (unknownVars.length > 0) {
        console.log("");
        console.log("[WARNING] Variables inconnues dans le template:");
        for (var i = 0; i < unknownVars.length; i++) {
            console.log("  - {{" + unknownVars[i] + "}}");
        }
        console.log("Ces variables n'ont pas été remplacées.");
    }
}
