/*
 * Modern Template Processor v2.0 - Jinja2-inspired
 *
 * A clean template engine with explicit variable binding and proper scoping.
 *
 * Syntax:
 * - Variables: {{variable.property}}
 * - Loops: {{#each collection as item}}...{{/each}}
 * - Conditions: {{#if condition}}...{{else}}...{{/if}}
 * - Filters: {{#each elements | filter:type="goal" as elem}}
 * - Helpers: {{element.name | uppercase}}
 * - Loop metadata: {{loop.index}}, {{loop.first}}, {{loop.last}}, {{loop.length}}
 *
 * Version 2.0 - Breaking changes from v1.0:
 * - "as variable" syntax is now MANDATORY for loops
 * - Auto-singularization removed
 * - Proper scope stack implementation
 *
 */

// Load helpers
load(__DIR__ + "templateHelpers.ajs");

// =====================================================
// Scope Management
// =====================================================

/**
 * Scope class for managing variable context in nested structures
 */
function Scope(parent, data) {
    this.parent = parent || null;
    this.vars = {};

    // If data provided, add all its properties to this scope
    if (data) {
        for (var key in data) {
            if (data.hasOwnProperty(key)) {
                this.vars[key] = data[key];
            }
        }
    }
}

/**
 * Set a variable in current scope
 */
Scope.prototype.set = function(name, value) {
    this.vars[name] = value;
};

/**
 * Get a variable, searching up the scope chain
 * Supports nested property access like "item.properties.Status"
 */
Scope.prototype.get = function(path) {
    var parts = path.split(".");
    var firstPart = parts[0];

    // Try current scope
    if (firstPart in this.vars) {
        var value = this.vars[firstPart];

        // Navigate nested properties
        for (var i = 1; i < parts.length && value != null; i++) {
            value = value[parts[i]];
        }

        return value;
    }

    // Try parent scope
    if (this.parent) {
        return this.parent.get(path);
    }

    // Not found
    return undefined;
};

/**
 * List all available variables in scope (for error messages)
 */
Scope.prototype.listVars = function() {
    var vars = Object.keys(this.vars);
    if (this.parent) {
        vars = vars.concat(this.parent.listVars());
    }
    return vars;
};

// =====================================================
// Main Processing Function
// =====================================================

/**
 * Process a template with view data
 * @param {string} template - Template content (Markdown with template syntax)
 * @param {object} data - View data from extractCompleteViewStructure or deduplicateViewData
 * @returns {string} Processed template
 */
function processTemplate(template, data) {
    console.log("Processing template...");

    // Create root scope with data
    var rootScope = new Scope(null, data);

    // Validate template syntax
    var validation = validateTemplate(template);
    if (!validation.valid) {
        console.error("Template validation failed:");
        for (var i = 0; i < validation.errors.length; i++) {
            console.error("  Line " + validation.errors[i].line + ": " + validation.errors[i].message);
        }
        throw new Error("Template has syntax errors");
    }

    // Process in order: loops, conditionals, variables
    var result = template;
    result = processLoops(result, rootScope, 0);
    result = processConditionals(result, rootScope);
    result = processVariables(result, rootScope);

    // Warn about unprocessed template syntax
    warnUnprocessedTags(result);

    console.log("Template processing complete");
    return result;
}

// =====================================================
// Template Validation
// =====================================================

/**
 * Validate template syntax before processing
 * @param {string} template - Template content
 * @returns {object} {valid: boolean, errors: [{line: number, message: string}]}
 */
function validateTemplate(template) {
    var errors = [];
    var lines = template.split("\n");

    // Track open/close tags
    var openTags = [];

    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var lineNum = i + 1;

        // Find all template tags in this line
        var tagRegex = /\{\{([#/]?)(\w+)([^}]*)\}\}/g;
        var match;

        while ((match = tagRegex.exec(line)) !== null) {
            var prefix = match[1];  // # or / or empty
            var command = match[2]; // each, if, else, variable name
            var args = match[3];    // arguments

            if (prefix === "#") {
                // Opening tag - validate "as" syntax for #each
                if (command === "each") {
                    if (args.indexOf(" as ") === -1) {
                        errors.push({
                            line: lineNum,
                            message: "Loop must use 'as' syntax: {{#each collection as item}}"
                        });
                    }
                }
                openTags.push({command: command, line: lineNum});
            } else if (prefix === "/") {
                // Closing tag
                if (openTags.length === 0) {
                    errors.push({line: lineNum, message: "Unexpected closing tag: {{/" + command + "}}"});
                } else {
                    var lastOpen = openTags.pop();
                    if (lastOpen.command !== command) {
                        errors.push({
                            line: lineNum,
                            message: "Mismatched tags: expected {{/" + lastOpen.command + "}} but found {{/" + command + "}}"
                        });
                    }
                }
            } else if (command === "else") {
                // Else tag - check it's inside an if or each
                if (openTags.length === 0) {
                    errors.push({line: lineNum, message: "{{else}} without matching {{#if}} or {{#each}}"});
                }
            }
        }
    }

    // Check for unclosed tags
    if (openTags.length > 0) {
        for (var i = 0; i < openTags.length; i++) {
            errors.push({
                line: openTags[i].line,
                message: "Unclosed tag: {{#" + openTags[i].command + "}}"
            });
        }
    }

    return {
        valid: errors.length === 0,
        errors: errors
    };
}

// =====================================================
// Loop Processing
// =====================================================

/**
 * Process {{#each collection as item}}...{{else}}...{{/each}} loops
 * @param {string} template - Template content
 * @param {Scope} scope - Current scope
 * @param {number} depth - Recursion depth (for safety)
 * @returns {string} Processed template
 */
function processLoops(template, scope, depth) {
    if (depth > 20) {
        throw new Error("Maximum loop nesting depth exceeded");
    }

    // Process loops one at a time, matching nested {{each}} with correct {{/each}}
    var result = template;
    var changed = true;

    while (changed) {
        changed = false;

        // Find the FIRST {{#each ...}} tag
        var startPattern = /\{\{#each\s+([\w.]+)\s+as\s+(\w+)(\s*\|[^}]*)?\}\}/;
        var startMatch = result.match(startPattern);

        if (!startMatch) {
            break; // No more loops to process
        }

        var startIndex = result.indexOf(startMatch[0]);
        var collectionPath = startMatch[1];
        var itemName = startMatch[2];
        var filters = startMatch[3] || "";

        console.log("Processing loop at depth " + depth + ": " + collectionPath + " as " + itemName);

        // Find the matching {{/each}} by counting nesting levels
        var searchStart = startIndex + startMatch[0].length;
        var nestLevel = 1;
        var endIndex = -1;

        var eachPattern = /\{\{#each\s+[\w.]+\s+as\s+\w+(?:\s*\|[^}]*)?\}\}/g;
        var endEachPattern = /\{\{\/each\}\}/g;

        eachPattern.lastIndex = searchStart;
        endEachPattern.lastIndex = searchStart;

        while (nestLevel > 0) {
            var nextEach = eachPattern.exec(result);
            var nextEndEach = endEachPattern.exec(result);

            if (!nextEndEach) {
                throw new Error("Unmatched {{#each}} - missing {{/each}}");
            }

            // Check if there's a nested {{#each}} before the next {{/each}}
            if (nextEach && nextEach.index < nextEndEach.index) {
                nestLevel++;
                eachPattern.lastIndex = nextEach.index + nextEach[0].length;
                endEachPattern.lastIndex = nextEach.index + nextEach[0].length;
            } else {
                nestLevel--;
                if (nestLevel === 0) {
                    endIndex = nextEndEach.index;
                } else {
                    eachPattern.lastIndex = nextEndEach.index + nextEndEach[0].length;
                    endEachPattern.lastIndex = nextEndEach.index + nextEndEach[0].length;
                }
            }
        }

        // Extract the loop content (between opening and closing tags)
        var loopContent = result.substring(searchStart, endIndex);
        var fullMatch = result.substring(startIndex, endIndex + 9); // +9 for {{/each}}

        // Check for {{else}} clause
        var elseIndex = loopContent.indexOf("{{else}}");
        var mainContent = loopContent;
        var elseContent = "";

        if (elseIndex !== -1) {
            mainContent = loopContent.substring(0, elseIndex);
            elseContent = loopContent.substring(elseIndex + 8); // length of "{{else}}"
        }

        // Get collection from scope
        var collection = scope.get(collectionPath);

        var replacement = "";

        if (!collection) {
            console.log("Collection not found: " + collectionPath);
            console.log("Available variables: " + scope.listVars().join(", "));
            if (elseContent) {
                replacement = elseContent;
                replacement = processVariables(replacement, scope);
                replacement = processConditionals(replacement, scope);
                replacement = processLoops(replacement, scope, depth + 1);
            }
        } else if (!Array.isArray(collection)) {
            console.log("Property is not a collection: " + collectionPath);
            if (elseContent) {
                replacement = elseContent;
                replacement = processVariables(replacement, scope);
                replacement = processConditionals(replacement, scope);
                replacement = processLoops(replacement, scope, depth + 1);
            }
        } else {
            // Apply filters if present
            if (filters) {
                collection = applyFilters(collection, filters.substring(1).trim()); // Remove leading |
            }

            // If collection is empty, use else clause
            if (collection.length === 0) {
                if (elseContent) {
                    replacement = elseContent;
                    replacement = processVariables(replacement, scope);
                    replacement = processConditionals(replacement, scope);
                    replacement = processLoops(replacement, scope, depth + 1);
                }
            } else {
                // Process each item
                for (var i = 0; i < collection.length; i++) {
                    var item = collection[i];

                    // Create new scope for this iteration
                    var itemScope = new Scope(scope);
                    itemScope.set(itemName, item);

                    // Add loop metadata
                    itemScope.set("loop", {
                        index: i + 1,           // 1-based
                        index0: i,              // 0-based
                        first: i === 0,
                        last: i === collection.length - 1,
                        length: collection.length
                    });

                    // Process the iteration content: conditionals first, then nested loops, then variables
                    // Conditionals must be processed before variables so variables inside conditionals are resolved
                    var itemOutput = mainContent;
                    itemOutput = processConditionals(itemOutput, itemScope);
                    itemOutput = processLoops(itemOutput, itemScope, depth + 1);
                    itemOutput = processVariables(itemOutput, itemScope);

                    replacement += itemOutput;
                }
            }
        }

        // Replace the full loop with the processed output
        result = result.substring(0, startIndex) + replacement + result.substring(endIndex + 9);
        changed = true;
    }

    return result;
}

// =====================================================
// Conditional Processing
// =====================================================

/**
 * Process {{#if condition}}...{{else}}...{{/if}} conditionals
 * @param {string} template - Template content
 * @param {Scope} scope - Current scope
 * @returns {string} Processed template
 */
function processConditionals(template, scope) {
    // Pattern: {{#if condition}}...{{else}}...{{/if}}
    var conditionalPattern = /\{\{#if\s+([^}]+)\}\}([\s\S]*?)(?:\{\{else\}\}([\s\S]*?))?\{\{\/if\}\}/g;

    var result = template.replace(conditionalPattern, function(match, condition, trueContent, falseContent) {
        var conditionMet = evaluateCondition(condition, scope);

        if (conditionMet) {
            return trueContent;
        } else {
            return falseContent || "";
        }
    });

    return result;
}

/**
 * Evaluate a condition expression
 * Supports: variable, variable.length, variable.length > 0, !variable
 */
function evaluateCondition(condition, scope) {
    condition = condition.trim();

    // Handle negation
    var negated = false;
    if (condition.charAt(0) === "!") {
        negated = true;
        condition = condition.substring(1).trim();
    }

    // Handle comparisons (simple: > < >= <= == !=)
    var comparisonMatch = condition.match(/^([\w.]+)\s*([><=!]+)\s*(.+)$/);
    if (comparisonMatch) {
        var left = scope.get(comparisonMatch[1].trim());
        var operator = comparisonMatch[2];
        var right = comparisonMatch[3].trim();

        // Try to parse right side as number
        if (/^\d+$/.test(right)) {
            right = parseInt(right);
        } else {
            // Try as variable
            var rightValue = scope.get(right);
            if (rightValue !== undefined) {
                right = rightValue;
            }
        }

        var result;
        switch (operator) {
            case ">": result = left > right; break;
            case "<": result = left < right; break;
            case ">=": result = left >= right; break;
            case "<=": result = left <= right; break;
            case "==": result = left == right; break;
            case "!=": result = left != right; break;
            default: result = false;
        }

        return negated ? !result : result;
    }

    // Simple variable evaluation
    var value = scope.get(condition);

    // Check truthiness
    var isTruthy = value !== undefined && value !== null && value !== false && value !== "" && value !== 0;

    return negated ? !isTruthy : isTruthy;
}

// =====================================================
// Variable Processing
// =====================================================

/**
 * Process {{variable}} and {{variable | helper}} tags
 * @param {string} template - Template content
 * @param {Scope} scope - Current scope
 * @returns {string} Processed template
 */
function processVariables(template, scope) {
    // Pattern: {{variable.path | helper1 | helper2}}
    var variablePattern = /\{\{([^#\/}][^}]*?)\}\}/g;

    var result = template.replace(variablePattern, function(match, expression) {
        // Skip {{else}} tags
        if (expression.trim() === "else") {
            return match;
        }

        // Split expression into variable path and helpers
        var parts = expression.split("|").map(function(s) { return s.trim(); });
        var variablePath = parts[0];
        var helpers = parts.slice(1);

        // Get variable value
        var value = scope.get(variablePath);

        if (value === null || value === undefined) {
            console.log("Variable not found: " + variablePath);
            console.log("Available variables: " + scope.listVars().join(", "));
            return "";
        }

        // Apply helpers
        for (var i = 0; i < helpers.length; i++) {
            value = applyHelper(value, helpers[i]);
        }

        // Convert to string
        if (typeof value === "object") {
            // Don't stringify objects, just show [Object]
            return "[Object]";
        }

        return String(value);
    });

    return result;
}

// =====================================================
// Helper and Filter Application
// =====================================================

/**
 * Apply a helper function to a value
 * @param {any} value - Input value
 * @param {string} helperExpr - Helper expression (e.g., "truncate:50")
 * @returns {any} Transformed value
 */
function applyHelper(value, helperExpr) {
    var colonIndex = helperExpr.indexOf(":");
    var helperName = colonIndex > 0 ? helperExpr.substring(0, colonIndex).trim() : helperExpr.trim();
    var helperArg = colonIndex > 0 ? helperExpr.substring(colonIndex + 1).trim() : null;

    // Call helper function from templateHelpers.ajs
    switch (helperName) {
        case "uppercase":
            return value ? String(value).toUpperCase() : value;
        case "lowercase":
            return value ? String(value).toLowerCase() : value;
        case "escape":
            return escapeMD(value);
        case "truncate":
            var maxLength = helperArg ? parseInt(helperArg) : 50;
            return truncateText(value, maxLength);
        case "newlines":
            return value ? String(value).replace(/\n/g, "<br>") : value;
        case "number":
            return formatNumber(value);
        case "default":
            return value || helperArg || "";
        default:
            console.log("Unknown helper: " + helperName);
            return value;
    }
}

/**
 * Apply filters to a collection
 * @param {array} collection - Input collection
 * @param {string} filterString - Filter expression (e.g., "filter:type='goal' | sort:by='name'")
 * @returns {array} Filtered collection
 */
function applyFilters(collection, filterString) {
    // Split by pipe to handle multiple filters
    var filters = filterString.split("|").map(function(s) { return s.trim(); });

    var result = collection;

    for (var i = 0; i < filters.length; i++) {
        var filter = filters[i];

        if (filter.startsWith("filter:")) {
            // Parse filter expression
            var filterExpr = filter.substring(7); // Remove "filter:"
            result = applyFilter(result, filterExpr);
        } else if (filter.startsWith("sort:")) {
            // Parse sort expression
            var sortExpr = filter.substring(5); // Remove "sort:"
            result = applySort(result, sortExpr);
        } else if (filter === "deduplicate") {
            result = deduplicateArray(result);
        }
    }

    return result;
}

/**
 * Filter collection by property value
 */
function applyFilter(collection, filterExpr) {
    // Parse expression like: type="business-capability" or isGroup="true"
    var match = filterExpr.match(/(\w+)="([^"]+)"/);
    if (!match) {
        console.log("Invalid filter expression: " + filterExpr);
        return collection;
    }

    var property = match[1];
    var value = match[2];

    // Convert boolean strings
    if (value === "true") value = true;
    if (value === "false") value = false;

    return filterBy(collection, property, value);
}

/**
 * Sort collection by property
 */
function applySort(collection, sortExpr) {
    // Parse expression like: by="name"
    var match = sortExpr.match(/by="([^"]+)"/);
    if (!match) {
        console.log("Invalid sort expression: " + sortExpr);
        return collection;
    }

    var property = match[1];
    return sortBy(collection, property);
}

// =====================================================
// Utility Functions
// =====================================================

/**
 * Warn about unprocessed template tags
 * @param {string} content - Processed content
 */
function warnUnprocessedTags(content) {
    var unprocessedPattern = /\{\{[^}]+\}\}/g;
    var matches = content.match(unprocessedPattern);

    if (matches && matches.length > 0) {
        console.log("Warning: Unprocessed template tags found:");
        for (var i = 0; i < Math.min(matches.length, 5); i++) {
            console.log("  " + matches[i]);
        }
        if (matches.length > 5) {
            console.log("  ... and " + (matches.length - 5) + " more");
        }
    }
}

/**
 * Escape markdown special characters
 */
function escapeMD(text) {
    if (!text) return "";
    return String(text)
        .replace(/\\/g, "\\\\")
        .replace(/\*/g, "\\*")
        .replace(/_/g, "\\_")
        .replace(/\[/g, "\\[")
        .replace(/\]/g, "\\]")
        .replace(/\(/g, "\\(")
        .replace(/\)/g, "\\)")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
}

/**
 * Truncate text to max length
 */
function truncateText(text, maxLength) {
    if (!text) return "";
    text = String(text);
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + "...";
}

/**
 * Format number with thousands separator
 */
function formatNumber(value) {
    if (value === null || value === undefined) return "";
    return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
